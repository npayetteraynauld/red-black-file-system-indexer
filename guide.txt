Project Description:

Create a lightweight filesystem indexer and search engine using a Red-Black Tree as the core data structure for storing and managing metadata about files. 
This tool will recursively scan a given directory and build an in-memory Red-Black 
Tree index that enables efficient operations like:

    Insertions and deletions of file metadata as files are added/removed

    Efficient search by filename, size, or timestamp

    Range queries, like finding files modified between two dates

    Sorted listing of files based on user-defined keys

Core Features:

    Red-Black Tree Implementation (Core Requirement)

        Self-balancing BST for storing file metadata (filename, path, size, last modified date)

        Fully implemented by you (not dict, not bisect, etc.)

        Supports insert, delete, search, in-order traversal

    Directory Scanner

        Recursively scan a directory and build the tree with file metadata

        Optionally ignore hidden files or symbolic links

    Search & Query Interface

        CLI or GUI to allow searching files by:

            Exact filename

            Size range

            Date modified range

            Sorted output (e.g., by name, size, or modified time)

    Live Monitoring (Optional but Interesting)

        Use something like watchdog to monitor a directory

        Automatically update the tree as files are added, removed, or changed

    Export & Import Tree

        Serialize the Red-Black Tree to disk (e.g., using pickle or JSON)

        Load the tree on startup for persistent indexing

    Unit Tests

        Comprehensive test coverage for tree operations and query logic
Stretch Goals:

    Add a basic GUI using tkinter or PyQt

    Build a visualizer for the tree (optional, for learning)

    Use multi-threading for scanning large directories

Why This Project?

    Red-Black Trees are central and not a peripheral component

    Youâ€™ll need to implement complex operations like balancing on insert/delete

    It blends systems programming, algorithms, and software design

    Can evolve into a real tool with file search capabilities faster than some OS search functions
âœ… Red-Black Tree Basics Recap

A Red-Black Tree is a type of Binary Search Tree (BST) where:

    Each node has at most two children: a left and a right.

    Nodes are organized by a comparable key (e.g., filename or file size).

    Balancing rules (e.g. red/black coloring) ensure operations stay O(log n).

So yes, a single node in an RBT can only have two child nodes â€” but each node can store more than just a single value.
ğŸ—‚ï¸ How to Handle Multiple Files

Each file is an individual record in your tree. You donâ€™t store a whole directory as one node â€” you store each file as its own node. Here's how that works:
Option 1: Key = Full File Path or Filename

    Each file gets its own node.

    The RBT uses filename or filepath as the key to sort the tree.

    Multiple files in the same directory are inserted one-by-one.
Imagine this structure:

/mydir/
  
a.txt
b.txt,
c.txt,
,

You insert each:

insert("a.txt", FileMetadata("/mydir/a.txt", 1200, ...))
insert("b.txt", FileMetadata("/mydir/b.txt", 1500, ...))
insert("c.txt", FileMetadata("/mydir/c.txt", 800, ...))

Now you can:

    Search for "b.txt" in O(log n)

    Traverse all files in sorted filename order

    Find files between "a.txt" and "c.txt"
Summary
Concept    Explanation
RBT Node    Can store any data, but only has two child links (left/right)
Multiple Files    Insert each file as a separate node into the RBT
Best Practice    Use filename or full path as the tree key
Benefit    Allows efficient searching, inserting, and listing
rbfs_indexer/
â”œâ”€â”€ main.py
â”œâ”€â”€ rb_tree/
â”‚   â”œâ”€â”€ init.py
â”‚   â”œâ”€â”€ node.py
â”‚   â””â”€â”€ tree.py
â”œâ”€â”€ indexer/
â”‚   â”œâ”€â”€ init.py
â”‚   â”œâ”€â”€ scanner.py
â”‚   â”œâ”€â”€ metadata.py
â”‚   â””â”€â”€ watcher.py         # optional (for live file monitoring)
â”œâ”€â”€ cli/
â”‚   â”œâ”€â”€ init.py
â”‚   â””â”€â”€ interface.py
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ init.py
â”‚   â””â”€â”€ serializer.py
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ test_tree.py
â”‚   â”œâ”€â”€ test_scanner.py
â”‚   â””â”€â”€ test_queries.py
â”œâ”€â”€ README.md
â”œâ”€â”€ requirements.txt
â””â”€â”€ .gitignore
rb_tree/

Your Red-Black Tree implementation.

    node.py: Defines the RBTreeNode class.

    tree.py: Implements the Red-Black Tree (insert, delete, search, traverse, etc.).

indexer/

Handles all filesystem operations and file metadata.

    scanner.py: Walks the directory and creates file metadata objects.

    metadata.py: FileMetadata class with attributes like filename, size, path, modified time.

    watcher.py: (Optional) Uses watchdog to update the tree on file changes.

cli/

The command-line interface.

    interface.py: Accepts user commands like search, list, range-query, etc., and calls the RBT functions.

utils/

Helper functions.

    serializer.py: Handles saving/loading the Red-Black Tree (e.g., using pickle, JSON, or custom format).

tests/

Unit tests using unittest or pytest.

    test_tree.py: Tests insert/delete/balance/search.

    test_scanner.py: Tests that files are correctly scanned and turned into metadata.

    test_queries.py: Tests range queries and filters.
main.py initializes the RBT.

scanner.py walks a user-specified directory and returns a list of FileMetadata objects.

Each file is inserted into the RBT from tree.py.

interface.py listens for user input like:

list by name
find "notes.txt"
between size 1000 20000
ğŸ§  Tips for Development

    Start with tree.py and get a fully working, tested Red-Black Tree.

    Then build scanner.py and metadata.py to feed it real data.

    Only once you can insert/search real files into the tree should you start working on the CLI.

    Don't worry about serialization or watcher.py until later â€” these are nice-to-haves.
